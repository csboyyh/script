#!/bin/bash

DEBUG="true"

temp_dir=dapm
widget_db=$temp_dir/widget.txt
dapm_ctx=$temp_dir/dapm.txt
path_db=$temp_dir/path.txt

DEBUG()
{
    if [ $DEBUG = "true" ];then
        $@
    fi
}
function usage
{
    echo "Usage:source dapm.sh dapm_context.txt,which generated by script"
    echo -e "\t will build dapm struct and output active paths"
    echo "we have fllowing functions avaible"
    echo -e "\t 1.find_path_by_widget:show path consists the widget"
    echo -e "\t\t arg1:must widget_name"
    echo -e "\t\t arg2:option state,On or Off"
    echo -e "\t\t\t ex:find_path_by_widget "Inter HP PA" will show you the HP PA paths"
    echo -e "\t 2.show_active_paths:show current active paths"
    echo -e "\t 3.find_path_by_source_sink:find a path from source to sink"
    echo -e "\t\t arg1:must source widget name"
    echo -e "\t\t arg2:must sink widget name"
    echo -e "\t 4.show_widget_info:show widget attribute,name:source or sink:curret state"
    echo -e "\t\t arg1:must widget name"
}

function help_and_prepare
{
    usage
    
    if [ ! -f $1 ];then
        echo "no input file:"$1
        exit
    fi

    if [ -d $temp_dir ];then
        rm -rf $temp_dir
    fi
    mkdir $temp_dir
    uniq $1 >$dapm_ctx
    dos2unix $dapm_ctx
    touch $path_db
    path_count=0
    unset wpath
    idx=0
}

function format_dapm_context
{
    grep "^[^ ]" $dapm_ctx | awk -F ":" '{print length($1)":"$1}' | sort -nr |uniq |awk -F ":" '{print $2}'>$widget_db
    while read widget
    do
        replace=`echo $widget |sed "s/ /-/g"`
        DEBUG echo $replace
        sed "s/$widget/$replace/g" -i $dapm_ctx
        sed "s/$widget/$replace/g" -i $widget_db
        sed "s/\"//g" -i $dapm_ctx
    done < $widget_db
}

function build_dapm_struct
{
    unset filename
    unset stream
    while read line
    do
        array=(${line//:/ })
        DEBUG echo "line context:"${array[@]}
        case ${array[0]} in
            out)
                echo ${array[${#arry[@]}-1]}>>$temp_dir/$filename"_out"
                ;;
            in)
                echo ${array[${#arry[@]}-1]}>>$temp_dir/$filename"_in"
                ;;
            stream)
                stream="stream"
                ;;
            *)
                if [ -n $filename ];then
                    if [ ! -f $temp_dir/$filename"_out" -a ! -f $temp_dir/$filename"_in" ];then
                        sed "/^$filename$/s/$/:isolate/g" -i $widget_db
                    elif [ ! -f $temp_dir/$filename"_out" ];then
                        endpoint=1
                        sed "/^$filename$/s/$/:sink/g" -i $widget_db
                    elif [ ! -f $temp_dir/$filename"_in" ];then
                        sed "/^$filename$/s/$/:source/g" -i $widget_db
                        endpoint=1
                    else
                        sed "/^$filename$/s/$/:pipe/g" -i $widget_db
                    fi
                    sed "/^$filename:.*/s/$/:$state/g" -i $widget_db
                    
                    if [ $endpoint -eq 1 ];then
                        if [ "$stream"x = "stream"x ];then
                            sed "/^$filename:.*/s/$/:$stream/g" -i $widget_db
                        elif [ "$is_supply"x = "true"x ];then
                            sed "/^$filename:.*/s/$/:supply/g" -i $widget_db
                        fi
                    fi
                fi
                #Analog-Power: On  in 0 out 0
                filename=${array[0]}
                state=${array[1]}
                if [ "$state"x = "On"x -a ${array[3]} -eq 0 -a ${array[5]} -eq 0 ];then
                    is_supply="true"
                else
                    is_supply="false"
                fi
                stream="false"
                endpoint=0
        esac
    done < $dapm_ctx
}

function reverse_array
{
    local p_arr=($(echo "$@"))
    local r_arr=${p_arr[@]}
    local size=$[ $# - 1 ]
    for ((i=0;i<=$size;i++))
    do  
         r_arr[$i]=${p_arr[$size-$i]}
     done
     echo ${r_arr[*]}
}

function recrusive_dapm_path
{
    local widget=$1
    local dir=$2
    local state=$3 
    local w_state=$(grep "^$widget:.*" $widget_db |awk -F ":" '{print $3}')
    local supply=""


    DEBUG echo "widget:"$widget" dir:"$dir" idx:"$idx
    
    if [ $state != "On" -o $w_state != "On" ];then
        state="Off"
    fi

    if egrep "$widget.*supply" $widget_db -q;then
        supply="Supply-path:"
    fi
    wpath[$idx]=$widget"("$w_state")"
    if [ ! -e $temp_dir/$widget"_"$dir ];then
        if [ $dir = "out" ];then
            echo $supply$path_count":"$state":"${wpath[@]}>>$path_db
        else
            arg=$(echo ${wpath[*]})
            ret=($(reverse_array $arg))
            echo $supply$path_count":"$state":"${ret[*]}>>$path_db
        fi
        let path_count++
        unset wpath[$idx]
        return
    fi

    while read itera
    do
        let idx++
        DEBUG echo "itera:"$itera
        recrusive_dapm_path $itera $dir $state
        unset wpath[$idx]
        let idx--
    done < $temp_dir/$widget"_"$dir
}

function find_path_by_widget
{
    local widget=`echo $1 | sed "s/ /-/g"`
    local string=$(grep $widget $widget_db)
    local array=(${string//:/ })
    local state="(On|Off)"
    local option=""

    if [ $# -ge 3 ];then
        option="-q"
        state=$2
    elif [ $# -ge 2 ];then
        state=$2
    fi

    if [ ${#array[*]} -eq 0 ];then
        echo "unknown widget:"$1
    fi

    DEBUG echo "find "$widget" from current path"
    if egrep "^[0-9]+:(On|Off):$widget\($state\).*" $path_db $option ||   
        egrep "^[0-9]+:(On|Off):.*$widget\($state\)$" $path_db $option;then
        return
    else
        DEBUG echo "start to build path"
    fi

    case ${array[1]} in
        isolate)
            echo "isolated widget,no path"
            ;;
        source)
            recrusive_dapm_path $widget "out" "On"
            ;;
        sink)
            recrusive_dapm_path $widget "in" "On"
            ;;
        pipe)
            recrusive_dapm_path $widget "out" "On"
            recrusive_dapm_path $widget "in" "On"
        ;;
    esac
    
    DEBUG echo "find "$widget" from current path again"
    if egrep "^[0-9]+:(On|Off):$widget\($state\).*" $path_db $option ||   
        egrep "^[0-9]+:(On|Off):.*$widget\($state\)$" $path_db $option;then
        return
    else
        echo "no path about["$widget":"$state"] found"
    fi
}

function show_active_paths
{
    echo "parsing current active path"

    if ! grep ":On$" $widget_db -q;then
        echo "no active widget,so no active path"
        return
    fi

    grep ":On" $widget_db | while read line
    do
        local desr=(${line//:/ })
        if [ ${#desr[@]} -ge 4 ];then
            if [ ${desr[3]} != "supply" ];then
                echo "start from:"${desr[0]}
                find_path_by_widget ${desr[0]} "On" "quiet"
            fi
        fi
    done
    egrep "^[0-9]+:On.*" $path_db
}

function find_path_by_source_sink
{
    if [ $# -ne 2 ];then
        echo "invalid args,must 2,one for source,one for sink"
        return
    fi

    local wid1=`echo $1 | sed "s/ /-/g"`
    local wid2=`echo $2 | sed "s/ /-/g"`
    if ! grep "^$wid1:source.*" $widget_db;then
        echo $wid1" is not a source widget"
        return
    elif ! grep "^$wid2:sink.*" $widget_db;then
        echo $wid2" is not sink widget"
        return
    fi

    find_path_by_widget $wid1 "On|Off" "quiet"

    echo $(egrep "^[0-9]+:(On|Off):$wid1.*$wid2\((On|Off)\)$" $path_db| wc -l)" records found"
    egrep "^[0-9]+:(On|Off):$wid1.*$wid2\((On|Off)\)$" $path_db
}

function show_widget_info
{
    local widget=`echo $1 | sed "s/ /-/g"`
    if [ $# -lt 1 ];then
        echo "need one arg at least"
        return
    fi
    echo "widget-name:arrtibute:state"
    grep $widget $widget_db
}

help_and_prepare $1
format_dapm_context
build_dapm_struct
show_active_paths
